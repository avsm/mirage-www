We're excited to announce MirageOS 3.0!  [Full release notes are available on GitHub](https://github.com/mirage/mirage/releases/tag/v3.0.0), but here's a summary of the bits we're most excited about:

### Solo5

MirageOS 3.0.0 is the first release that integrates the solo5 targets, `virtio` and `ukvm`, fully with the `mirage` front-end tool.  Now you can `mirage configure -t ukvm`, build a unikernel, and run directly with the generated `ukvm-bin`!  We've updated the "hello world" tutorial to reflect our excitement about `ukvm` -- the `ukvm` target is considerably easier to interface with and configure than `xen` was, and for a lot of users this will be a clearer path toward operational deployment of unikernels.

For a lot more information on the Solo5 targets, see [the earlier blog post announcing solo5](/tmpl/blog/introducing-solo5), [Unikernel Monitors: Extending Minimalism Outside of the Box](https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/williams), and [the very readable solo5 repository README](https://github.com/solo5/solo5/tree/master/README.md).  It's also possible to [run solo5 unikernels on FreeBSD via bhyve](https://hannes.nqsb.io/Posts/Solo5).

We'd like to thank particularly, but in no particular order, the following people who contributed to Solo5: Dan Williams, Martin Lucina, Ricardo Koller, Hannes Mehnert, Ian Campbell, helpful GitHub users myechuri and waldyrious, Anil Madhavapeddy, Sean Grove, and David Kaloper.

### Playing More Nicely with OPAM

MirageOS 3 has a much richer interface for dealing with the package manager and external library dependencies.  A user can now specify a version or range of versions for a package dependency, and the `mirage` front-end tool will construct a custom `opam` file including both those package dependencies and the ones automatically generated from `mirage configure`.  `mirage` will also consider version constraints for its own packages -- from now on, `opam` should notice that releases of `mirage` are incompatible with your unikernel.

For more information on dealing with packages and dependencies, the documentation for [the Functoria.package function](https://mirage.github.io/functoria/Functoria.html#VALpackage) will likely be of use.  [The PRNG device-usage example in mirage-skeleton](https://github.com/mirage/mirage-skeleton/blob/mirage-dev/device-usage/prng/config.ml) demonstrates some useful invocations of `package`.

We'd like to thank particularly, but in no particular order, the following people who contributed to this improvement with code, suggestions, or testing: Hannes Mehnert, Gabriel Radanne, Sean Grove, Richard Mortier, Mindy Preston, Thomas Leonard, Anil Madhavapeddy, David Scott, Vincent Bernardoff, and Thomas Gazagnaire.

### Amazing Docs

Thanks to a lot of hard work, a fully interlinked set of module documentation is now automatically generated by `odig` and available for your reading pleasure at [the MirageOS central documentation repository](https://docs.mirage.io).  While documentation was previously available for most modules, it was scattershot and often required having several disconnected pages open simultaneously.  We hope you'll find the new organization more convenient.

We'd like to thank particularly, but in no particular order, the following people who contributed to this improvement with code, suggestions, or testing: Daniel Bünzli, Anil Madhavapeddy, Thomas Gazagnaire, Thomas Leonard, Mindy Preston, Liang Wang, Hannes Mehnert, David Sheets, and Louis Gesbert.

### Result-y Errors

The module types provided by MirageOS 3 replace the previous error paradigm (a combination of exceptions and directly returning polymorphic variants) with one that uses [the Result module included in OCaml 4.03 and up](https://github.com/ocaml/ocaml/pull/147).  The MirageOS 3 module types define a core set of likely errors for each module type (see [the mirage-flow module type](https://mirage.github.io/mirage-flow/Mirage_flow.S.html) for an example), which can be extended by any given implementation.  Module types now specify that each implementation must include a pretty-printer that can handle all emitted error types.  Functions that return a `success` type when they run as expected return a `(success, error) Result.t`, which the caller can print with `pp_error` if the value is an `Error`.

For more background on the result type, see the [Rresult library](http://erratique.ch/software/rresult) which defines further useful operations on `Result.t` and is used widely in MirageOS libraries, and [a forthcoming in-depth explanation of errors](TODO write then link).

We'd like to thank particularly, but in no particular order, the following people who contributed to this improvement with code, suggestions, testing, and moral support: Hannes Mehnert, Thomas Gazagnaire, Thomas Leonard, Mindy Preston, Ashish Agarwal, Leo White, Anil Madhavapeddy, Dave Scott, and Daniel Bünzli.

### Logs Where You Want Them

MirageOS version 2.9.0 included automatic support for logging via the `Logs` and `Mirage_logs` library, but by default logs were always printed to the console and changing the log reporter was cumbersome.  In MirageOS 3, you can send logs to a consumer of syslog messages with `syslog_udp`, `syslog_tcp`, or with the full authentication and encryption provided by `ocaml-tls` using `syslog_tls`.  For more information, see [the excellent writeup at hannes.nqsb.io](https://hannes.nqsb.io/Posts/Syslog).

We'd like to thank particularly, but in no particular order, the following people who contributed to this improvement with code, suggestions, testing, related libraries, and discussion: Hannes Mehnert, Jochen Bartl, Gabriel Radanne, GitHub user wiredsister, Daniel Bünzli, Anil Madhavapeddy, and Thomas Leonard.

### Disaggregated Module Type Definitions

Breaking all of the MirageOS 3.0 APIs showed us that keeping them all in the same place made updates really difficult.  There's now an additional set of packages which contain the definitions for each set of module types (e.g. [mirage-fs](https://github.com/mirage/mirage-fs) for the `FS` module type, [mirage-block](https://github.com/mirage/mirage-block) for the `BLOCK` module type, etc).  A few module types had some additional useful code that was nicely functorized over the module type in question, so we've bundled that code in the module type packages as well.  Documentation for all of the module type packages is available at [the Mirage documentation hub](https://mirage.github.io/doc/).

We hope that this change combined with the `opam` workflow changes above will result in *much* less painful API changes in the future, as it will be possible for unikernel authors to target specific versions more readily.

We'd like to thank particularly, but in no particular order, the following people who contributed to this improvement with code, suggestions, downstream porting, and testing: Hannes Mehnert, Thomas Gazagnaire, Mindy Preston, Anil Madhavapeddy, and Dave Scott.

### Clockier Clocks, Timelier Time

In older MirageOS versions, we noticed that we were often having to deduce a span of time from having taken two wall-clock samples of the current time.  In MirageOS 3, you have your choice of two types of clock - `MCLOCK`, which provides a monotonically increasing clock reflecting the time elapsed since the clock started, and `PCLOCK`, which provides a traditional POSIX wall-clock time.  Most previous users of `CLOCK` were able to migrate to the more-honest, less-complicated `MCLOCK`.  For an example of both clocks, see [the speaking clock](https://github.com/mirage/mirage-skeleton/blob/mirage-dev/device-usage/clock/unikernel.ml).  You may also be interested in [an example of converting existing code from `CLOCK` to `MCLOCK`](https://github.com/mirage/mirage-tcpip/pull/232/files).

`MCLOCK` provides a nice interface for dealing with time at a nanosecond granularity.  The `TIME` module type has been updated to expect an `int64` number of nanoseconds, rather than a float, as an argument to its function `sleep`.  For those of us who don't think in nanoseconds, the [Duration](https://github.com/hannesm/duration) library provides convenient functions for translating from and to more familiar units like seconds.

We'd like to thank particularly, but in no particular order, the following people who contributed to this improvement with code, suggestions, and testing: Matt Gray, Daniel Bünzli, Hannes Mehnert, Mindy Preston, Nick Betteridge, Thomas Gazagnaire, Thomas Leonard, David Sheets, Richard Mortier, and Anil Madhavapeddy.

### Build System Shift

In many but not all MirageOS packages, we've replaced `oasis` with `topkg`, the "transitory OCaml software packager". `topkg` is a lighter layer over the underlying `ocamlbuild`.  Using `topkg` has allowed us to remove several thousand lines of autogenerated code across the MirageOS package universe, and let our release manager automate a significant amount of the MirageOS 3 release process.  We hope to continue benefitting from the ease of using `topkg` and `topkg-care`.

Not all packages are using `topkg` yet -- if you see one that isn't, feel free to submit a PR!

We'd like to thank particularly, but in no particular order, the following people who contributed to this improvement by writing or improving `topkg`, converting existing packages, or using `topkg` in new packages which were automatically releasable: Daniel Bünzli, Hannes Mehnert, Federico Gimenez, David Kaloper, Jochen Bartl, Thomas Gazagnaire, Leonid Rozenberg, Anil Madhavapeddy, Mindy Preston, and Dave Scott.

### Many, Many Other Changes

There's more in MirageOS 3 than we can fit in one blog post without our eyes glazing over.  The release notes for `mirage` version 3.0.0 are a nice summary, but you might also be interested in the full accounting of chanes for every package released as a part of the MirageOS 3 effort.  Generally speaking, 
